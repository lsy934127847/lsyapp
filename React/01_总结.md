
# 创建React脚手架环境
1. 全局安装脚手架       npm install create-react-app -g
2. 创建项目            create-react-app myapp
3. 进入项目            cd myapp
4. 启动项目            npm start
5. 修改默认启动端口号  "start": "set PORT=9000 && react-scripts start",

#下载相关包
1. npm install -S react         包含了React 和 React-Native 所共同拥有的核心代码，主要用于生成虚拟Dom
1. npm install -S react-dom     包含了针对不同平台渲染不同内容的核心代码，主要用于 将虚拟Dom 转化成 真实Dom
1. npm install -S react-router-dom

1. npm install -S redux
1. npm install -S react-redux

1. npm install mobx mobx-react -S

# 引入相关资源
import react from 'react'     
import ReactDOM from 'react-dom'    
import { BrowserRouter,HashRouter,Link,Route,NavLink,Switch,withRouter } from 'react-router-dom'
import {createStore} from  'redux'
import { connect } from 'react-redux'

#  安装 React Developer Tools  调试工具
 安装步骤 打开谷歌浏览器-更多工具-扩展程序-点击扩展程序-点击打开chrome网上应用商店-搜索React Developer Tools -安装添加
 无法打开chrome网上应用商店时-下载 谷歌访问助手插件，将该插件插入到浏览器扩展程序中，注册账号即可
 打开本地文件，无法使用该调试工具时：打开该插件，详细信息，勾选允许访问 文件网址 即可


# React 核心思想: 数据驱动界面更新(数据-界面)  组件化开发

#父子组件如何通信
1. 父组件向子组件 通过props传值
2. 通过mobx 定义的store对象,被Provider包裹的所有子组件都可以获取到store对象中的数据和方法
2. 通过Redux,在函数式组件使用hooks的获取状态和派发任务以修改状态
3. 子组件向父组件数据  通过自定义事件,子组件通过props触发父组件的自定义事件,并传递参数实现

#JSX的本质，作用 好处
1. 最终JSX将转换成   React.createElment('div') 语法来生成虚拟Dom对象,并通过ReactDOM.render方法虚拟Dom 渲染到页面
2. jsx可以快速搭建视图结构,并书写js代码，可以给元素绑定属性，事件，控制显隐，列表循环等复杂操作,使用了原生的js代码来操作了React元素

#Context 是什么，如何应用
1. Context 是通过生产者(Provider 生产数据)，被Provider包裹的子组件都可以消费数据(Consumer),实现父子通讯

#shouldComponentUpdate 的用途
1. 性能优化,通过相关判断,决定是否要执行后续的render方法


#redux 
 * 核心概念
1. 单一数据源,state是只读的,只能使用纯函数Reducer执行修改
2. Redux 提供可预测化的状态管理，让 state 的变化变得可预测
3. Redux 在复杂应用和庞大系统时优秀的扩展能力,它可以用 action 追溯应用的每一次修改.如录制用户会话并回放所有 action 来重现它。

#setState 场景
1.  setState 默认是异步的,在事件函数和setTimeout中是同步的
2.  React 会收集所有的setState 将传递的对象或者函数进行 遍历 ,将结果合并到原始对象中
3.  当setState 传递的参数为 对象时, 经过遍历合并的语法后，最终以书写位置的最后一个对象 相关的计算结果为准
4.  当setState 传递的参数为 函数时， 经过遍历合并后, 每次都可拿到新值,

#React 生命周期
1. React 生命周期一共有8个 常用的有6个
2. constructor componentDidMount  shouldComponentUpdate  render  componentDidUpdate  componentWillUnmount
3. 

#React发起的ajax请求应放在哪里

#渲染列表 ,为何使用key
1. 性能优化，减少渲染次数,提升渲染性能

1. 当数据发生改变触发render方法时,React 通过diff算法来比较新旧虚拟Dom的变化,
2. 当列表循环元素位置发生改变时,通过key 可以有效避免删除和添加节点的多余操作

1. key值应保证唯一性,尽量避免使用数组索引指定key值


#函数组件和class 组件的区别
1. 利用构造函数定义 ,返回React元素
2. 没有生命周期,没有state,没有this指向复杂问题
3. 函数组件的性能比类组件的性能要高,类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可

1. 类组件用class定义,继承于React.Component 类,有生命周期和state

# 受控组件
1. 表单的值，受state数据控制,需要自行监听 onChange ,更新state,及简单实现了数据的双向绑定

1. 在jsx中,我们给元素绑定的属性和事件并不能一贯认为它和原生的Dom属性和事件是一样的,React可能对它进行了封装
2. 比如React 中的受控组件中 input的value 属性和onchange事件,
3. 原生设置value属性后不会影响用户对表单的操作,原生的onchange事件在表单内容发生改变并失焦,才会触发
4. 如果希望给表单不受控制,不要绑定value属性,但想要设置默认值时可以给其绑定defaultValue 属性

#何时使用异步组件,如何使用,在React环境中，如何实现“代码分割”？
1. 加载大组件
2. 路由的异步加载
3. 
// cnpm install @loadable/component -S
// import loadable from '@loadable/component'
// 把所有路由匹配组件都写成 const Home = loadable(()=>import('./Home.js'))
// 如果报了 动态import 语法错误，请安装这个babel插件
// cnpm install @babel/plugin-syntax-dynamic-import -D
// 在 babel.config.js 中添加一个plugins配置，重启项目即可

#没有被Route 创建React组件，是没有向组件传递路由相关Api的。
1. 在类组件中，只能使用 withRouter 来解决问题。
1. 在无状态组件中，可以使用 withRouter，也可以使用 useHistory来解决问题。
1. withRouter 是一个高阶组件，让那些没有被Route组件直接包裹的React组件拥有路由API
1. useHistory 是ReactRouter提供的Hooks API，帮助我们在无状态组件中使用路由API

# 多个组件有公共逻辑,如何抽离
1. 高阶组件

#React 性能优化
1. 路由,图片懒加载
2. 渲染列表使用key
3. 自定义事件、Dom事件，定时器及时销毁
4. 合理使用异步组件
5. 减少函数bind this的次数
6. 合理使用SCU PurComponent 和memo
7. 合理使用Immutable.js|不可变值
8. 使用SSR

#PureComponent 和Component 有何区别
1. 实现了浅比较的shouldComponentUpdate
2. 性能优化 父组件的数据的改变不希望子组件也改变(阻止子组件render)


# React 事件和Dom事件的区别
1. 所有事件挂载到document 上
2. event 不是原生的，是SynthetiEvent 合成事件对象
3. dispatchEvent 机制

#React 和Vue的区别
1. 都支持组件化
2. 都是数据驱动视图 
3. 都是用vdom操作DOM

1. React 使用jsx 拥抱js Vue 使用模板拥抱HTML
2. React 函数式编程《Vue 生命式编程
3. Vue 提供了各种指令来渲染元素 React 需要用js代码实现

# React 中的this 问题
1. 在React 中在给React元素添加 事件时,会修改函数处理函数的this为undefined
2. 可以在constructor 中手动修改this 为当前实例,该方法在初始化渲染时 只会执行一次,
3. 一般不在事件处理函数中去用bind 修改this ，这会导致数据变动，触发render ，重复绑定
4. 使用箭头函数

#组合(基于props) 组件复用 和继承

#高阶组件，如何理解高阶组件，在项目中的具体使用
1. 高阶组件,本质上是一个函数,可以对传入的组件进行包装,在返回一个新的组件
2. 作用：它是React中业务逻辑复用的一种解决方案
3. 使用高阶组件时应注意组件树的顺序,以便清晰的知道组件的之前的联系，以免造成组件通讯传值混乱
// 高阶组件是基于React组合特性而得来的一种设计模式、软件开发经验
// 高阶组件，也被称之为高阶函数、纯函数、容器组件
```javascript
function gaojieComponent(ParamsComponent){
    class Adv extends React.Component{
        render(){
            return (
                <div>
                    <ParamsComponent></ParamsComponent>
                </div>
            )
        }
    }
    return Adv
}
```
#hook 
概念:为了解决无状态组件 没有类组件相关特性的问题 而封装的一系列方法
常用的有 useState useEffect useDispatch  useSelector

 useState :a.通过useState方法定义组件的状态和修改状态的方法,直接修改状态将不起任何作用。通过解构出来的方法修改状态，状态表面上看就是一个变量
           b. 当状态发生改变的时候,要注意函数体内代码被重新执行的情况(执行了哪些代码)(暂不考虑 hooks  api )
           c. 有些代码,当改变状态的时候,不需要重新执行,应写在 函数组件外面(暂不考虑 hooks  api )
useEffect :a.第一参数为回调函数,当组件挂载完成  和  数据发生改变的时候触发
           b. 第二个参数为一个数组,数组中可写通过useState解构出来的相关变量,表示只有当该变量发生改变时，第一个回调函数才会执行
           c.注意:如果不写第二个参数,只要数据发生变化,第一个回调就会执行,当为空数组时,指在挂载阶段执行一次,
useSelector : 用来获取状态管理的中数据
useDispatch  : 用来派发任务,        

使用 引入 import React,{useState} from 'react';
```javascript
  // useState 
  // 参数: 保证初始的状态
  // 返回值: 1. 是一个数组,数组中两个元素,第一个元素:保存的状态,第二个元素:修改保存状态的方法,  永远都是是异步的
  const  [Agestate,setAgeState] =  useState(25)
  const  [Userstate,setUserState] =  useState({name:'lisi',age:36})
  setUserState({name:'lsy',age:25})   // 修改状态


    // 组件 被挂载或组件更新完成执行回调函数  可通过第二个参数 一个数组 来决定哪些的改变 才会执行 回调和return 返回的函数
    useEffect(()=>{
      console.log('组件 被挂载或组件更新完成执行回调函数')

      // 组件被卸载后执行return 返回的函数  只要 数据发生了改变 该函数就会执行
      return ()=>{
        console.log('组件被卸载后执行')
      }
    },[nameState])  // 只有当nameState 发改变时才会执行回调函数 和return 返回的函数
```
#状态管理

状态管理工具 ，是用来对应用程序总的数据流进行科学的管理

最早出现状态管理思想的是Flux ，Flux只是一套数据流管理的指导思想，设计模式

mobx   mobx-react  小项目经常用  npm install mobx mobx-react -S

mobx 5+  mobx-react 6+
mobx 6+  mobx-react 7+

redux  redux-react 大项目经常用

mobx 的使用
mobx的好处，为什么要使用mobx，mobx具体该如何使用

 mobx 只是用于定义store
 mobx-react 是帮助我们在React组件中使用store  借助 mobx-react 的上下文和高阶组件

 #mobx 的使用
 1. 下载相关依赖 npm install mobx mobx-react -S
 2. 引入相关资源 
    定义store时引入                                import {observable,action,makeAutoObservable,computed, makeObservable} from 'mobx'
    在组件中使用时引入                              import {inject,observer} from 'mobx-react'
    用于包裹子组件,并将store对象传给所有子组件        import {Provider} from 'mobx-react'


 3. 基本思想:将数据存入store对象中,借助react 上下文传递store对象,被Provider包裹的所有子组件都可以通过props参数获取store对象
 
 具体步骤 
 1. 创建store对象
```javascript
   import {observable,action,makeAutoObservable,computed, makeObservable} from 'mobx'
class Store {
    list = []
    constructor(){
        // makeAutoObservable(this)  // 表示将所有的属性和方法 都设置为被观察的
        makeObservable(this,{       //指定属性和方法
            list:observable,
            addTask:action,        
            delTask:action,
            total:computed     //  相当于计算属性    
        })
    }
    addTask(payload){
       // 用于请求数据和修改store 数据
    }
    delTask(payload) {
        
    }

    // 相当于计算属性
   get total(){
        return this.list.length
    }
}
export default new Store()
```
2. import store from './store/index.js'
   <Provider  store = {store}>子组件 <Provider / >

3. Home组件使用
   import {inject,observer} from 'mobx-react'
   export default  inject('store')(observer(Home))  
 



