
# Vue 和React 的区别  +1  +1  +1

# hooks Api 

#redux的使用流程

#首屏加载的方式

#浏览器的事件循环



#在用 React 做项目时，有哪些优化方式，解决了哪些问题



#ant design 常用的组件，用过哪些

vue 
#vue 数据双向绑定原理(+1)，生命周期，vuex（+1），mvvm的理解，组件通信,初始化对象的几个重要属性和区别 keep-alive  history和hash模式  动态路由
#vue 响应式原理
#vue-router 路由守卫  过滤器

#vue 渲染为啥要有根组件     slot 插槽
#nextTick  的兼容性如何处理
  
http

#输入url到页面展示出来发生了什么过程  +1  +1  +1  +1

#缓存和浏览器哦缓存  资源缓存304  http 状态码   强缓存 协商缓存  如何设置，如何使用

#loaclstrage 和sessionstrage  和cookie 有何区别  +1

#http 和 https协议   三次握手  4次挥手

#前后端遇到的跨域问题,怎么解决,是选择前端的跨域方案还是后端的跨域方案

#axios 请求的参数  如何使用  请求拦截器 和响应拦截器

#get 请求 和 post 请求的区别

#前端攻击

#tcp  udp

react 

#React  setState hooks 封装的组件  key的作用  虚拟Dom (和vue虚拟DOM区别)  生命周期  组件通信  diff算法广度优先  ant design
#类组件和函数式组件的区别，优缺点
#vuex 和Redux 是解决什么什么问题的     
#vue如何使用动态加载组件
# redux 的执行流程  ，react-redux  和redux  有何区别  redux 的中间件 thunk 解决了什么问题 和saga 有和区别

#react 和vue 的区别
 相同点:a.都是数据驱动页面更新 
        b.都有虚拟Dom,组件化开发,通过props进行父子组件间数据的传递
        c.都支持服务端的渲染SSR 
        d.都有支持native的方法,react有 React native  Vue有wexx
 不同点: a.数据绑定:Vue 实现了数据的双向绑定,React是




html css
#各种居中  上代码
#清除浮动   上代码

#display:none visibility:hidden  区别
   相同点 : DOM都节点都存在  
   不同点 :  a. display :none 不占据空间,隐藏本身及所有后代,后代不会继承该属性 后代不可通过display:block 来显示.修改display属性
               通常会造成文档重排  
             b.visibility:hidden 占据空间,后代会继承该属性,后代可通过设置visibility:visible显示,但要注意继承关系.修改visibility属性只会造成本元   素的重绘

     重排:添加,删除可见Dom,元素位置和几何特征改变,浏览器窗口尺寸改变
     重绘:某个元素的vidibility、outline、背景颜色发生改变

#请谈一谈对BFC的理解 





#选择器
#opacity 和rbga设置透明度有什么区别
1.opacity 是属性，rgba()是函数，计算之后是个属性值；
2.opacity 作用于元素和元素的内容，内容会继承元素的透明度，取值0-1；
3.rgba() 一般作为背景色 background-color 或者颜色 color 的属性值，只作用于当前元素的背景颜色和字体颜色

扩展：
1.transparent 也是透明，是个属性值，颜色值，跟#000是一类，不过它是关键字来描述。
#css的预处理器 
sass less 可以使用变量,判断,循环,函数，继承,混入等功能,可以更加方便简洁得查找到元素
#css的盒模型
1.一个元素的 都是由content+padding+border+margin 构成
2.在标准盒模型下   设置元素的属性  width = content
3.在怪异盒模型下  当设置box-sizing:为border-box 之后         设置元素的属性 width = content+border+padding
4.在弹性盒模型下   元素内部全部布局方式遵循弹性布局规则
#弹性盒模型
1.灵活,快速的调整布局,自适应性强,通过设置相关属性,按照比例去分配空间,减少了额外的计算
#img标签中alt和title属性有何区别
1.图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化
2.图片中的 title属性是在鼠标在移动到元素上的文本提示。
#css 选择器权重
!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
#行内元素，块级元素，空元素有哪些
1.行内元素:a , span , 
2.行内块:img  input select
3.块级:div ul ol li h1-h5  p
4.空元素:<br><hr>
#html5新增了哪些标签
1.video ，audio ，


js
#冒泡排序 

#数组去重  +1  +1
1.利用set数据结构的特性去重
```javascript
var arr = [1,5,6,5,6,10,5]
var set  = new Set(arr)
var newArr = [...set]
```
2.利用indexOf
```javascript
var arr = [1,5,6,5,6,10,5]   var newArr = []
for(var i=0;i<arr.length;i++){
  if(newArr.indexOf(arr[i]) === -1){
    newArr.push(arr[i])
  }
}
console.log(newArr)
```
3.利用filter去重
```javascript
var arr = [1,5,6,5,6,10,5]  
var newArr = arr.filter((val,idx,arr){
  if(arr.indexOf(val) === idx)return true
})
```

# 手写深拷贝,对深拷贝和浅拷贝的理解
 // 1. 深拷贝:将旧变量赋值给新变量之后,修改新变量 不会 影响原有变量的值 (基本数据类型)
 // 2. 浅拷贝:将旧变量赋值给新变量之后,修改新变量  会  影响原有变量的值 (引用数据类型) 因为两者指向了同一块堆内存
```javascript
function depCopy(target,source){
    for(let key in source){
        let sourceValue = source[key]
        // 判断是否为基本数据类型，如果是则直接 赋值
        if( !(sourceValue instanceof Object)){       
            target[key] = sourceValue
        }else{   
        // 是否为数组和对象或函数
            let subTarget = new sourceValue.constructor
            target[key] = subTarget
        //  递归实现 深复制
            depCopy(subTarget,sourceValue)
        }
    }
}
var newobj = {}
var obj = {name:'lsy',person:{name:'lisi'}}
depCopy(newobj,obj)
```
#promise 相关  then catch all race async await，手写 

#变量提升
1.在代码执行时,首先执行进行域解析，检查是否有语法错误，然后将声明提升
2.将通过var定义的变量和function定义的函数提升到作用域的最前面，
3.声明提升时函数的优先级高于变量，函数提升是整体提升
4.箭头函数和 let，const 定义的变量没有声明提升


# 手写防抖 节流 +1  +1  +1
 函数防抖
  // 函数防抖是 优化高频率执行js代码的一种手段
  // 可以让被调用的函数在一次连续的高频操作过程中只被调用一次
```javascript
    let oIpt = document.querySelector('input')
    let timer = null
    oIpt.oninput = function(){
        timer && clearTimeout(timer)
        // 
        timer = setTimeout(function(){
            console.log(oIpt.value)
        },2000)
    }
```
函数节流
  // 函数节流  优化高频执行js代码的一种手段
  //  函数节流 被优化的代码可能执行多次 执行的次数  大致为变化的总时间/定时器的延迟时间  利用了一个标识变量
```javascript
  let flag = true
window.onresize = function(){

     if(!flag){
         return
     }
     flag = false
   setTimeout(function(){
       flag = true
       fn()
   },2000)
}
```

#谈一谈typeOf 和instanceOf
1.typeOf 检测变量数据类型 返回一个字符串 检测数组,对象,null类型时返回object 检测函数时返回function
2.A instanceOf B 返回bool值,判断构造函数(B)的原型对象是否出现在了某一对象(A)的原型链中

#严格模式
es5 新增
1.声明严格模式 'use strict'
2.严格模式下:a.变量要先定义后使用
            b.函数形参不可以重复,会报错


#undefined 和null 的区别  
1. 判断变量为undefined  的情况
   a. 函数没有设置返回值,默认返回undefined
   b. 函数调用没有传递实参
   c. 声明变量未赋值
2. 判断为null的 情况
   a.获取一个不存在Dom节点
   b.原型链的终点
3. typeOf 检测数据类型不同  null类型变量 返回object undefined类型返回undefined
4. 当转为数字类型时不同 null类型为 0  undefined 为NaN
5. 相等判断时为true,三等判断时为false

# let 和var 的区别
1. let声明的变量不存在变量提升,只能先定义再使用,否则会报错。不能同一块级作用域中重复声明同一变量,会报错
2. var 声明的变量,被函数和全局作用域所限定,let声明的变量被块级作用域所限定
3. 都遵循变量逐级向上的访问原则,同级不能访问

##this指向  call bind  apply的区别和具体使用

1.普通函数中this 指向window
2.作为对象中方法中的this,谁调用此方法,this就指向谁
3.构造函数中this,指向实例对象
4.箭头函数中的this指向和当前函数上下文保持一致,可粗略的理解为和父级函数this指向保持一致

1.call 方法 语法 fn.call(要改变的this指向,函数的实参) 函数会立即调用
2.apply 方法 语法 fn.apply(要改变的this指向,[函数的实参])   函数会立即调用
3.bind 方法 语法 fn.bind(要改变的this指向)  函数没有被调用，返回了新的函数

# es6 Set map 
1. Set a.es6 新增的一种数据结构,近似于数组,同过new Set() 可创建Set实例.
       b.最大特点就是所有元素都是唯一的，没有重复,可利用这一特性进行数组去重
2. Map a.Map 是 ES6 中新增的数据结构，类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型.

#原型链
1.通过对象的__proto__属性指向 连接的链叫做原型链
2.对象在访问属性和方法时，先在自身查找,然后依次在__proto__属性指向的对象中查找,

#闭包 +1  内存泄漏
1.当函数作用域内部的变量被外部作用域所引用时,形成闭包。
2.由于形成闭包后,函数的执行空间不会被销毁,会一致占用内存,导致内存溢出,有时需手动释放内存 

#回流和重绘


node
#koa和express的区别
1.了解哪些模块和常用方法
2.node的异步编程是怎么实现的
3.node用过哪些中间件


项目优化
#seo优化
#性能优化
#介绍一下你所在的项目
#如何解决首页加载时间过长
#平时
#在公司造过轮子吗
#在工作项目中遇到的难点
#当用户打开一个页面，非常慢，有什么情况可导致
#前端有哪些性能优化，解决了哪些问题

#介绍一下你所在的项目 管理系统,webapp
1. 项目用到的核心技术
2. 项目中用到了哪些性能优化,解决了一些哪些问题
3. 项目中遇到了哪些难点
4. 项目从开发到上线用了多长时间。
5. 自己所负责的功能模块,该模块实现了怎样的功能


物料管控后台管理系统

#负责的模块,平常的工作
不同部门人员所使用的功能界面，一般涉及到 物料的增啥改查, 相关功能权限控制
#具体讲一讲功能权限如何实现的
当某用户登录后,根据后端返回的字段将该功能按钮设置为禁用，或者该功能组件不会渲染出来
#具体讲一讲物料的增啥改查
在不同部门人员的功能界面时,用到了 ant design 框架中的 表单 表格 按钮 栅格系统 分页器 图片上传 下拉筛选框等组件
封装过 upload 和 select 业务组件,

#权限管理如何实现
1.不同用户的权限管理 ， 用户登录后，后端返回数组，根据数组渲染不同的界面
2.前端在做权限控制的时候，依赖于后端 API 返回的配置信息，所以在权限设计，路由设计，数据结构设计的时候，前后端一定要约定好。


webpack -----------------------------------------------------------------------------------------------------------------------

#自己配置过webpack吗,配置了哪些内容，解决了哪些问题
1.webpack配置过什么
2.使用webpack做过什么优化
3.配置loader 和plugin 的区别
TS
#对ts有了解吗，相比js ，有啥区别


http-------------------------------------------------------------------------------------------------------------

#从输入url 到页面渲染发生了什么
1.解析域名对应ip地址
  a.发出一个请求到本地DNS(域名分布系统)服务器,查询是否有缓存记录，如果有缓存记录直接返回结果.
  b.如果没有记录本地DNS继续向域服务器(.com域服务器)发送请求，域服务器返回域名和ip地址的对应关系到DNS服务器.
  c.本地DNS服务器把IP地址返回给客户端，并保存域名和ip地址，以便用户下次请求时，直接返回结果
2.建立TCP连接
  a.三次握手,确保数据传输无误
3.发起http请求资源
4.断开连接，4次挥手
3.浏览器解析资源，渲染页面

#get和post的区别

get参数直接拼接在了url地址栏后面
get请求传递参数大小是有限制的；
get安全性较低
get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳

post传递参数，需要把参数放进请求体中，发送给服务器；
post请求参数放进了请求体中，对大小没有要求；
post安全性比较高；
post请求不会走缓存，除非主动设置 



#.前端攻击
1.XSS 跨站脚本攻击 
  概念:植入了恶意js代码 
  防范: a. 对用户输入的数据进行过滤，比如script标签 保护cookie，
        b.  对重要的cookie设置httpOnly，防止客服端通过document.cookie获取cookie。
2.CSRF 跨站点伪造请求
  概念:a.攻击者盗用合法用户的身份，向服务器发送请求
       b.登录受信任网站A，并在本地生成cookie在不登出网站A的情况下访问危险网站B
  防范:a.验证 HTTP Referer 字段 b.在请求地址中添加token并验证 c.在HTTP头中自定义属性并验证
#http和https 的区别
1.http是超文本传输协议,https是ssl加密协议
2.http的默认端口是80，https 是443
#cookie sessionStorage 和 localStorage 的区别
1.存储大小:cookie的数据大小不能超过4k,sessionStorage 和 localStorage虽然也有存储大小的限制,但比cookie 大，可以达到5M或更大
2.有效时间:a.cookie 可以设置过期时间，在过期之前一直有效，即使窗口或浏览器关闭
           b. localStorage:永久保存数据,即使浏览器关闭也不会丢失，除非主动删除数据
           c. sessionStorage 数据在当前浏览器窗口关闭后自动删除

#浏览器的缓存机制
1.强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存.

   强缓存：不发起http请求，直接使用本地缓存，比如浏览器地址栏回车，使用浏览器的刷新按钮，在Expires或max-age生效的情况下，触发的都是强缓存。
   协商性缓存(弱缓存)：在使用本地缓存前，先与服务器协商，核对缓存文件是否为最新。

  缓存流程机制大致流程:浏览器查看是否有缓存,如果没有缓存,则直接向服务端发起http请求,如果有缓存，判断缓存是否过期,如果没有过期,则直接使用缓存,如果过期则再次向服务器发起请求判断资源是否有更新,如果有更新,重新返回资源和缓存标识，状态码为200，并存入缓存中.如果没有更新，则返回状态码304，继续使用缓存
              
#SEO  优化  
概念:做SEO是为了提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善用户体验，促进销售的作用。
<title>Document</title>
1.title 标签的设置  : title一般不超过80个字符,词语间要用英文“-”隔开,添加网站的关键性标题词语
<meta name=”Description” Content=”你网页的简述”>
2.meta 标签中Description的内容摘要 Content 属性中 填写 网站的内容摘要,主要栏目的标题、关键字、分类列表名称融合到里面
<meta name=”Keywords” Content=”关键词1,关键词2,关键词3,关键词4″>
3.meta 标签中Keywords关键字的填写
4.合理使用语义化标签让搜索引擎容易理解网页,常用的语义化标签是header footer nav article section aside
<img src="xxx.jpg" alt="海尔官网-双门冰箱" />
5.img 标签 alt 属性填写相应内容
6.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取
7.可以尽量给a标签加上title属性，可以更有利于抓取信息
8.少用iframe标签：搜索引擎不会抓取iframe中的内容

#前端性能优化
1.使用字体图标库和SVG格式的图片
2.使用图片懒加载
3.使用精灵图
4.避免使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源
5.减少对DOM操作，主要是减少DOM的重绘与回流（重排）
6.@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作
 
#在实际的React项目中进行过什么优化
1. 图片懒加载，路由懒加载,按需引入第三方组件库
2. 减少重新 render 的次数 执行render要进行diff算法，diff算法花费时间较长
3. 使用类组件时  shouldComponentUpdate和 PureComponent   进行优化 可以解决父组件更新而子组件不更新的情况
4. 函数式组件使用React.memo   useCallback   可以解决父组件更新而子组件不更新的情况
5. 使用useMemo的使用场景主要是用来缓存计算量比较大的函数结果，可以避免不必要的重复计算  与Vue 计算属性有异曲同工之妙
6. 合理拆分组件:例如 合理将一个大组件拆分成小组件，以减少diff 算法 的时间  比例一个很大的组件，仅仅改变了一个文本，diff算法却需要对比整个大组件

#状态码
200 表示成功
500 服务器方面的问题
404 找不到url 对应的资源文件
304 资源无更新,直接使用缓存
302 重定向

#js的事件循环机制
1. 依次从上至下执行所有同步代码,碰到异步代码分别放到宏任务和微任务队列中，所有同步代码执行完毕  再执行
   微任务队列中符合条件的代码，在执行所有符合条件的宏任务队列中的代码


#介绍自己的项目,最近的一个项目,负责的模块,怎么做的,有没有遇到什么难点,做过什么优化 


#vue 和react的区别
1. 在vue中可以直接修改声明式变量触发dom的更新，通过object.defineproperty 的set和get方法监听数据的变化,
   而在react中只能通过setState方法触发dom的更新,使用新state替换旧的state.